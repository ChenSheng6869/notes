# 1 Java常见面试题&代码实现

## 1 equals和==的区别是什么?

```java
public class TestEquals {
    public static void main(String[] args) {
        //对于基本类型和引用类型==的作用效果不同
        String x = "string";
        String y = "string";
        String z = new String("string");
        //x和y指向的是同一个引用
        System.out.println(x==y);//true
        //new String()方法重写开辟了内存空间，==结果为false
        System.out.println(x==z);//false

        //equals比较的一直是值，所以结果为true
        System.out.println(x.equals(y));
        System.out.println(z.equals(x));
        /*
        	关于equals
        	equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法        	
        */
    }
}
```

## 2 两个对象的hashCode相同,equals也一定为true?

equals相等,hashCode一定相等;反之不一定

```java
//equals相等,hashcode一定相等;反之不一定
public native int hashCode();
//native是一种Java方法,其实现是由非Java代码实现的.
//根据jdk文档，该方法的实现一般是“通过将该对象的内部地址转换成一个整数来实现的”
```

## 3 hashMap和hashTable的区别

HashMap:线程不安全,是map接口的实现类,是将建映射到值的对象,其中键和值都是对象,并且不能包括重复键,但可以包含重复值.HashMap允许null key和null value,而HashTable不允许.

```java
//HashMap线程不安全体现:
//putVal方法中会判断Hash碰撞,假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) 
//使HashMap在多线程的情况下进行线程安全的操作
//使用 Collections.synchronizedMap(map)，包装成同步Map，原理就是在HashMap的所有方法上synchronized。
//例如：Collections.SynchronizedMap#get()
public V get(Object key) {
    synchronized (mutex) {
        return m.get(key);
    }
}
    
```


HashTable :线程安全 Collection。HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 HashTable

> 两者区别:
>
> - HashMap允许将 null 作为一个 entry 的 key 或者 value，而 HashTable 不允许
> - HashMap 把 HashTable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解
> - HashMap是map接口的实现类,HashTable继承自Dictionary类
> - HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 HashTable时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步
> - HashTable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异

## 4 HTTP请求响应?状态码有哪些?含义

请求响应协议,通常运行在TCP之上.

## 4.1 http

超文本传输协议

端口:80

https默认端口443

## 4.2 两个时代

> http1.0

http/1.0:客户端可以与web服务器连接后,只能获得一个web资源,断开连接

> http2.0

http/1.1:客户端与服务器连接后,可以获得多个web资源

## 4.3 http请求

客户端----发请求----服务器

百度

```java
Request URL: https://www.baidu.com/				//请求地址
Request Method: GET								//get方法
Status Code: 200 OK								//
Remote Address: 127.0.0.1:11223
Referrer Policy: strict-origin-when-cross-origin
```

> **1请求行**

请求行中的请求方式:GET

请求方式:Get,Post,HEAD,DELETE,PUT,TRACT....

​	get:请求能够携带的参数比较少,大小有限制,会在浏览器的url地址栏显示数据内容,不安全,但高效

​	post:请求能够携带的参数没有限制,大小没有限制,不会在浏览器的url地址栏显示数据内容,安全,但不高效

> **2消息头**

​	accept:告诉浏览器,它所支持的数据类型

​	accept-encoding:支持哪种编码格式

​	accept-language:告诉浏览器的语言环境

​	cache-control:缓存控制

​	connection:告诉浏览器,请求完成是断开还是保持连接

​	host:主机

## 4.4 http响应

服务器----响应----客户端

```java
Cache-Control:private	//缓存控制
Connection: keep-alive
Content-Length: 161
Content-Type: text/html
Date: Sun, 06 Mar 2022 11:55:38 GMT
Location: https://www.baidu.com/
Server: bfe/1.0.8.18
```

> **1.响应体**

​	accept:告诉浏览器,它所支持的数据类型

​	accept-encoding:支持哪种编码格式

​	accept-language:告诉浏览器的语言环境

​	cache-control:缓存控制

​	connection:告诉浏览器,请求完成是断开还是保持连接

​	host:主机

​	Refresh:告诉客户端,多久刷新一次

​	location:让网页重新定位;

> **2.响应状态码**

200:请求响应成功

3XX:请求重定向

4XX:找不到资源 404

5XX:服务器代码错误 500	502(网关错误)

**常见面试题**

**浏览器中地址栏输入地址回车到展示页面,经历了什么?**



200	请求完成

301	请求的的数据具有新的位置且更改是永久的

304	资源移动,所请求资源自动到新的URL,浏览器自动跳转到新的URL

400	告诉客户端它发送了一个错误的请求

404	找不到服务器给定的资源,文档不存在

500	服务前内部出现错误

501	服务器遇到一个错误,使其无法对请求提供服务

## 5 volatile和synchronized的区别

1. volatile关键字是线程同步的轻量级实现,性能不synchronized关键字好.但是volatile只能用于变量,synchronized可以修饰方法和代码块.
2. 多线程访问volatile关键字不会阻塞,而synchronized关键字可能会发生阻塞
3. volatile保证数据的可见性,但不能保证数据的原子性.而synchronized关键字两者都能保证
4. volatile关键字主要解决变量在多个线程之间的可见性,synchronized解决多个线程之间访问资源的同步性

# 2 MySql面试题相关

## 1 关系型数据库和非关系型数据库

关系型数据库（SQL）：通过表和表之间，行和列之间的关系进行数据的存储

非关系型数据库（NoSQL） Not Only：redis，MongDB	对象存储，通过对象的属性来决定操作

DBMS（数据库管理系统）：数据库的管理软件
