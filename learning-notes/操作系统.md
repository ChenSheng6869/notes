2021/8/25 19:00

# 操作系统

## 1 导言

Q1：什么是操作系统？

应用程序->操作系统->计算机硬件。所以，可以称为是计算机硬件和应用之间的一层软件。

Q2：管理哪些硬件？

CPU管理、内存管理、终端管理、磁盘管理、文件管理。

学习目标：

1.改CPU管理

2.改屏幕输出

3.改系统接口

4.改内存管理

![image-20210825190308340](操作系统.assets\image-20210825190308340.png)

怎么学操作系统？

**实验一：扩展线程**		| **实现线程调度**

**实验二：实现系统调用** | **将整个接口剥掉**

**实验三：实现虚存管理** | **扩展实现内存管理**

**实验四：扩展文件系统** | **扩展实现一个文件管理**

## 2 正课

![image-20210825210011096](G:\03.学习笔记\操作系统.assets\image-20210825210011096.png)

输入->存储器->控制器->运算器->输出

Q：计算机怎么运行的？取指执行。

Q：打开电源，计算机执行的第一句指令是什么？

![image-20210825210254540](G:\03.学习笔记\操作系统.assets\image-20210825210254540.png)

引导扇区代码：bootsect.s

![image-20210825211449412](G:\03.学习笔记\操作系统.assets\image-20210825211449412.png)

boot工作：读setup，system

boot---setup---head---main------mem_init

## 3 操作系统的启动

Linux/Makefile* 控制大型软件合成必用

源码通过makefile产生一个镜像

## 4 操作系统接口

![image-20210830194849580](G:\03.学习笔记\操作系统.assets\image-20210830194849580.png)

## 5 系统调用的实现

## 6 操作系统历史

作业之间的切换和调度成为核心：因为既有IO任务，又有计算任务，需要使CPU忙碌

![image-20210901133558397](G:\03.学习笔记\操作系统.assets\image-20210901133558397.png)

进程管理：作为管理者，操作系统要让多个程序合理推进

![image-20210901134542615](G:\03.学习笔记\操作系统.assets\image-20210901134542615.png)

![image-20210901135636551](G:\03.学习笔记\操作系统.assets\image-20210901135636551.png)



### 进程

1.进程是进行中的程序

2.进程会走走停停，走停对程序无意义

3.进程需要记录ax，bx，程序不用

## 9 多进程图像

多个进程交替执行的样子 ——————交替三个部分：队列操作+调度+切换

多进程的组织：PCB+状态+队列

**PCB是用来记录进程信息的数据结构**

![image-20210902200343221](G:\03.学习笔记\操作系统.assets\image-20210902200343221.png)

## 10 用户级线程

线程：即保留了并发的优点，又避免了进程切换代价。能够执行起来且互相交换的序列

![image-20210902205436566](G:\03.学习笔记\操作系统.assets\image-20210902205436566.png)

![image-20210902205751671](G:\03.学习笔记\操作系统.assets\image-20210902205751671.png)

## 11 内核级线程

进程切换：从内核中切换：switch_to，sys_read()启动磁盘读，自己变为阻塞，找到next；switch_to(cur, next )

**用户级线程和内核级线程切换的核心是栈的切换**

## 12 内核级线程实现

![image-20210913104038938](G:\03.学习笔记\操作系统.assets\image-20210913104038938.png)

用户程序进入内核，靠的是中断，系统调用。fork是系统调用，会引起中断。

## 14 CPU调度策略

先来先服务，时间片轮转，基于优先级抢占调度

## 15 一个实际的schedule函数

![image-20210915202750054](G:\03.学习笔记\操作系统.assets\image-20210915202750054.png)

## 16 进程同步与信号量⭐⭐⭐

**信号量开始工作**（根据信号量进行唤醒）  C：consumer  P：producer  消费者进程，生产者进程（消费者调用V产生资源）

多个进程执行时，可以根据信号量的值，决定什么时候等，什么时候走

（1） 缓冲区满，P1执行，P1 Sleep  SEM = -1

（2）P2执行， 		P2 Sleep 		   SEM -= 2

（3）C执行1次循环， wakeup P1  	SEM -= -1

（4）C再执行1次循环， wakeup P2   SEM = 0

（5）C再执行1次循环，					  SEM = 1

（6）P3执行	还有一个空闲缓冲区 P2继续执行	SEM = 0

互斥信号量保证每次只有一个进程进去执行就阻塞

## 17 信号量临界区保护

什么是信号量？通过对这个量的访问和修改，让大家有序推进。

临界区：一次只允许一个进程进入的该进程的那一段代码

### **临界区代码的保护原则**

基本原则：互斥进入：如果一个进程再临界区中执行，则其他进程不允许进入

这些进程间的约束关系称为互斥（mutual exclusion）

### 好的临界区保护原则

**有空让进：**若干进程要求进入空闲临界区时，应尽快使一进程进入临界区

**有限等待：**从进程发出进入请求到允许进入，不能无限等待

## 19 死锁处理

多个进程在内存中同时触发，交替执行的时候可能会产生死锁，需要操作系统做出一些处理。

> **死锁的成因：资源互斥使用，一旦占有别人无法使用**
>
> 进程占有了一些资源，又不释放，再去申请其他资源
>
> 各自占有的资源互相申请的资源形成了环路等待

死锁产生的4个必要条件

![image-20210928152426113](G:\03.学习笔记\操作系统.assets\image-20210928152426113.png)

死锁处理方法概述

![image-20210928152905331](G:\03.学习笔记\操作系统.assets\image-20210928152905331.png)

请求出现时，先分配一次，调用银行家算法，如果会死锁，直接拒绝请求。

## L20 内存使用与分段

操作系统如何管理内存？

将一段程序放入内存中，取指-执行

内存使用：将程序放到内存中，PC指向开始地址（PC指向程序运行的地方）

1.找带内存中一段空闲的地方，将PCB指向空闲内存的基地址，放入执行，switch to

## L21 内存分区与分页

针对每个段内存请求，系统一页一页的分配给这个段

## L21 多级页表和快表

多级页表：页目录表（章）+ 页表（节）

多级页表提高了空间效率，时间上略不好。

TLB：相联快速存储，寄存器。

![image-20210929212110367](G:\03.学习笔记\操作系统.assets\image-20210929212110367.png)









