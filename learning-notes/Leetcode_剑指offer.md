# 剑指Offer📌

[TOC]

# 1 数组与矩阵

* 03.数组中重复的数字


* 04.二维数组中的查找


* 05.替换空格为%20✅
  * StringBuilder


* 29.顺时针打印矩阵


* 50.第一次只出现一次的数

# 2 栈队列、堆

* 09.两个栈实现队列✅
  * A,B分别作为入队,出队的栈

---

* 30.包含min函数的栈✅

---

* 31.栈的压入、弹出序列✅

---

- 40.最小的 K 个数✅**快排重点**🚨
  * **快排**+Arrays.copyOf(arr[], k);

---

- 41.1 数据流中的中位数(Hard),暂时忽略📕

  - 小顶堆+大顶堆

  - ```java
    Queue<Integer> A,B;
    A = new PriorityQueue<>();//小顶堆
    B = new PriorityQueue<>((x,y)->(y-x));//lambda表达式表示大顶堆
    ```

---

- 59.滑动窗口的最大值(Hard),暂时忽略📕

# 3 双指针

- 57.1 和为 S 的两个数字

---

- 57.2 和为 S 的连续正数序列
- 58.1 翻转单词顺序列
- 58.2 左旋转字符串

# 4 链表

- 6.从尾到头打印链表✅
  - **利用栈**:`LinkedList<Integer>() stack = new LinkedList<>();`📌
    - 1.入栈`stack.addLast(head.val)`
    - 2.出栈,放入数组`stack.removeLast()`
    - 3.返回数组

---

- 18.1 删除链表节点✅

  - 遍历链表,遍查遍删:`ListNode pre= head, cur = head.next;` 📌

    - 1.头节点就是要删除的节点;`return head.next;`

    - 2.遍历链表

      ```java
      while(cur != null && cur.val){
          pre = cur;
          cur = cur.next;
      }
      ```

    - 3.删除节点

      ```java
      //更改指针的指向,将当前节点从链表中删除
      if(cur != null) pre.next = cur.next;
      ```

---

- 18.2 删除链表中重复的结点✅

  - 重点:利用set的cotains方法,同18.1删除节点即可.**利用set集合**🚨

    - 1.初始化链表前驱,后置节点;

    - 2.**set用于保存节点的值** 🚨

      `HashSet<Integer> visited = new HashSet<>();`

    - 3.当前节点非空时,利用visited.cotains(cur.val)方法;

    - 4.若存在,删除当前节点

    - 5.不存在,继续遍历

---

- 22.链表中倒数第 K 个结点✅
  - 使用**双指针**🚨
    - 1.初始化节点,former,latter都指向头节点head
    - 2.让former与latter之间相隔k步,former往后走,直至相隔k步.
    - 3.当former为空时,former到链表尾部,与latter之间相隔k哥节点,latter节点即为所需要找的节点.

---

- 24.反转链表✅
  - **方法1:迭代,利用双指针**`cur = head, pre = null;` 🚨
    - 1.保存当前节点的下一个节点`ListNode temp = cur.next;` 
    - 2.将当前节点指向空指针(修改引用)`cur.next = pre;`
    - 3.将当前节点当作pre节点`pre = cur;`
    - 4.将保存的临时节点(next节点给cur)`cur = temp;`
  - **方法2:递归(待补充)** 🚩

---

- 25.合并两个排序的链表✅
  - **方法:初始化新节点(链表)**,`ListNode l3 = new ListNode(0), cur = l3;`
    - 0.l1,l2都不为空时(条件)
    - 1.比较l1,l2结点val的大小
    - 2.将小的节点插入
    - 3.l1,l2为null
    - 4.`cur.next = l1==null ? l2:l1`将后续链表节点插入
    - 5.`return l3.next` ,l3头节点为空,返回后续节点即可.

---

- 35.复杂链表的复制(Middle)❎

---

- 52.两个链表的第一个公共结点(Middle)❎

---

# 5 树

- 7.重建二叉树
- 8.二叉树的下一个结点
- 26.树的子结构
- 27.二叉树的镜像
- 28.对称的二叉树
- 32.1 从上往下打印二叉树
- 32.2 把二叉树打印成多行
- 32.3 按之字形顺序打印二叉树
- 33.二叉搜索树的后序遍历序列
- 34.二叉树中和为某一值的路径
- 36.二叉搜索树与双向链表
- 37.序列化二叉树
- 54.二叉查找树的第 K 个结点
- 55.1 二叉树的深度
- 55.2 平衡二叉树
- 68.树中两个节点的最低公共祖先

# 6 贪心思想

- 14.剪绳子
- 63.股票的最大利润

# 7 二分查找

- 11.旋转数组的最小数字
- 53.数字在排序数组中出现的次数

# 8 分治

- 16.数值的整数次方

# 9 搜索

- 12.矩阵中的路径
- 13.机器人的运动范围
- 38.字符串的排列

# 10 排序

- 21.调整数组顺序使奇数位于偶数前面
- 45.把数组排成最小的数
- 51.数组中的逆序对

# 11 动态规划

- 10.1 斐波那契数列
- 10.2 矩形覆盖
- 10.3 跳台阶
- 10.4 变态跳台阶
- 42.连续子数组的最大和
- 47.礼物的最大价值
- 48.最长不含重复字符的子字符串
- 49.丑数
- 60.n个骰子的点数
- 66.构建乘积数组

# 12 数学

- 39.数组中出现次数超过一半的数字
- 62.圆圈中最后剩下的数
- 43.从 1 到 n 整数中 1 出现的次数

# 13 位运算

- 15.二进制中 1 的个数
- 56.数组中只出现一次的数字

# 14 其它

- 17.打印从 1 到最大的 n 位数
- 19.正则表达式匹配
- 20.表示数值的字符串
- 44.数字序列中的某一位数字
- 46.把数字翻译成字符串
- 61.扑克牌顺子
- 64.求 1+2+3+...+n
- 65.不用加减乘除做加法
- 67.把字符串转换成整数

​